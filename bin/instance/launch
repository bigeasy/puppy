#!/usr/bin/env _coffee

# Used for debugging.
die = (splat...) ->
  console.log.apply console, splat if splat.length
  process.exit 1
say = (splat...) -> console.log.apply console, splat

fs = require("fs")
ec2 = require("ec2")
OptionParser = require("coffee-script/lib/coffee-script/optparse").OptionParser
dns = require("dns")

parser = new OptionParser [
  [ "-n", "--name [NAME]", "fully qualified domain name" ]
  [ "-a", "--architecture [NAME]", "architecture" ]
  [ "-s", "--size [NAME]", "instance size" ]
  [ "-h", "--help", "display puppy help" ]
]

usage = (message) ->
  process.stderr.write "error: #{message}\n"
  process.stderr.write parser.help()
  process.stderr.write "\n"
  process.exit 1

try
  options = parser.parse process.argv.slice(2)
catch e
  usage "Invalid arguments."

if not options.size
  options.size = "t1.micro"

if not options.name
  usage "Host name is required."

match = ///
    ^
    \w+\.
    (balance|user|data|image)\.
    (north|south|east|west)\.
    (california|oregon|ireland|singapore|tokyo|virginia)\.
    runpup\.com
    $
  ///.exec(options.name)

if not match
  process.stderr.write "Invalid hostname.\n"
  usage()
[ type, zone, region ] = match.slice 1

architecture = options.architecture || { balance: "x86_64", user: "i386", data: "i386" }[type] || "i386"

endpoint = { california: "us-west-1", oregon: "us-west-2", virginia: "us-east-1" }[region]
if not endpoint
  usage "Unknown region."

zone = {
    virginia: { north: "d", south: "b", east: "c", west: "d" }
    california: { north: "c", south: "b" }
    oregon: { north: "a", south: "b" }
}[region][zone]
if not zone
  usage "Unknown zone."

run = (_) ->
  configuration = JSON.parse fs.readFile "#{process.env["HOME"]}/.aws", "utf8", _
  configuration.endpoint = endpoint
  ec2 = ec2 configuration

  request = {}
  response = ec2 "DescribeInstances", {}, _
  instance = do ->
    for reservation in response.reservationSet
      for instance in reservation.instancesSet
        if not /^stopped|terminated$/.test instance.instanceState.name
          for tag in instance.tagSet
            if tag.key is "Name" and tag.value is options.name
              return instance

  if instance
    usage "An instance named #{options.name} is already running."

  response = ec2 "DescribeImages", { "Owner.1": "self" }, _
  request.image = do ->
    candidate = null
    for image in response.imagesSet
      tags = {}
      for tag in image.tagSet or []
        tags[tag.key] = tag.value or true
      if tags.Puppified and image.architecture is architecture and (not candidate or tags.Redux)
        candidate = image
    candidate

  response = ec2 "RunInstances", {
    ImageId: request.image.imageId
    MinCount: 1
    MaxCount: 1
    KeyName: "secret_key"
    UserData: new Buffer(options.name).toString("base64")
    InstanceType: options.size
    "Placement.AvailabilityZone": "#{endpoint}#{zone}"
  }, _

  request.instance = response.instancesSet.shift()
  loop
    response = ec2 "DescribeInstances", {}, _
    done = false
    for reservation in response.reservationSet
      for instance in reservation.instancesSet
        done = instance.instanceId is request.instance.instanceId
    break if done
    setTimeout _, 500

  ec2 "CreateTags", {
    "ResourceId.1": request.instance.instanceId
    "Tag.1.Key": "Name"
    "Tag.1.Value": options.name
  }, _

  loop
    response = ec2 "DescribeInstances", {}, _
    for reservation in response.reservationSet
      for instance in reservation.instancesSet
        if instance.instanceId is request.instance.instanceId
          done = instance.instanceState.name is "running"
    break if done
    setTimeout _, 500

  response = ec2 "DescribeInstances", { "InstanceId.1": request.instance.instanceId }, _
  for mapping in response.reservationSet[0].instancesSet[0].blockDeviceMapping
    if mapping.deviceName is "/dev/sda1"
      volumeId = mapping.ebs.volumeId
      break
  ec2 "CreateTags", {
    "ResourceId.1": volumeId
    "Tag.1.Key": "Name"
    "Tag.1.Value": options.name
  }, _

run (error) -> throw error if error
# vim: ft=coffee:
