#!/bin/bash

if [ $(whoami) != "root" ]; then
    echo "Must run as root." 1>&2
    exit 1
fi

function abend()
{
    local message=$1;
    echo "ERROR: ${message}"
    exit 1
}

# User and group generation.                                                            
# -------------------------------------------------------------------------- #
# User and group generation functions that check to see if the group already
# exists, followed by the invocation of the functions.
function make_group()
{
    local group=$1; local gid=$2
    current=$(/bin/grep "^${group}:" /etc/group | /bin/cut -d: -f3)
    if [ -z "$current" ]
    then
        echo "Creating group $group."
        /usr/sbin/groupadd --gid $gid $group
    elif [ "$current" != "$gid" ]
    then
        abend "Group $group exists with gid $current instead of $gid."
    fi
}

function make_user()
{
    local user=$1; local uid=$2;
    make_group $user $uid
    current=$(/bin/grep "^${user}:" /etc/passwd | /bin/cut -d: -f3)
    if [ -z "$current" ]
    then
        echo "Creating user $user."
        /usr/sbin/useradd --uid $uid --gid $uid $user
    elif [ "$current" != "$uid" ]
    then
        abend "User $user exists with uid $current instead of $uid."
    fi
}

# Users representing Puppy agents.
make_user   puppy         201
make_user   janitor       202
make_user   worker        204
make_user   database      205
make_user   system        207
make_user   vhosts        208
make_user   private       209
make_user   public        210
make_user   liminal       211
make_user   protected     212

# Users for built from source daemons.
make_user   haproxy       225
make_user   stunnel       226
make_group  loggers       227
make_user   unbound       228
make_user   common        229
make_user   exclusive     230

# Make all of the workers member of the common group.
function group_assign()
{
    local group=$1; min=$2; local max=$3;
    while read line
    do
        user=($(echo $line | /bin/awk -F: '{ print $1, $3 }'))
        if [ "${user[1]}" -ge $min  -a "${user[1]}" -le $max ]; then
            members=$(/bin/grep "^${group}:" /etc/group | /bin/cut -d: -f4)
            if echo $members | /bin/grep -wv ${user[0]} > /dev/null; then
                echo "Adding ${user[0]} to group $group."
                /usr/sbin/usermod -a -G $group ${user[0]} || abend "Cannot add ${user[0]} to $group."
            fi
        fi
    done < /etc/passwd
}

group_assign exclusive 202 210
group_assign loggers 1  700

# Hide the syslog.
# -------------------------------------------------------------------------- #

# We configure `rsyslog` to create the `log` socket in `/dev/loggers`, which is
# only readable by members of the `loggers` group, and then symlink `/dev/log`
# to our protected socket.
if [ ! -e /dev/loggers ]; then
    /bin/mkdir -m 750 /dev/loggers
    /bin/chown root:loggers /dev/loggers
    /bin/ln -s /dev/loggers/log /dev/log
fi

# Configuration installtion
# -------------------------------------------------------------------------- #

# More the printing of the restart ssh message than for the preservation of the
# distribution's ssh_config.
if [ ! -e /etc/ssh/sshd_config.org ]; then
    /bin/mv /etc/ssh/sshd_config /etc/ssh/sshd_config.org
    echo "You must restart sshd."
fi

# git does not perserve file permissions, in case you forgot.
#  http://kerneltrap.org/mailarchive/git/2008/12/5/4327894

# Install a file if the source is newer than the currently installed file.
function install_file()
{
    local source=$1; local dest=$2; local owner=$3; local mode=$4
    file=$(basename $source)
    /bin/mkdir -p $dest
    dirty=0
    if [ -e $dest/$file ]; then
        if [ $(/usr/bin/stat --format=%Y $source) -gt $(/usr/bin/stat --format=%Y $dest/$file) ]; then
            dirty=1
        fi 
    else
        dirty=1
    fi
    if [ $dirty -eq 1 ]; then
        echo "Installing file $dest/$file."
        install -m $mode -g $owner -o $owner $source $dest/$file
    fi
}

# Install all files matching a glob.
function install_files()
{
    local ownership=$1; local mode=$2;
    shift; shift;
    for file in $@; do
        /bin/mkdir -m $mode -p $(dirname $file)
        install_file $file $(dirname /$file)  $ownership $mode
    done
}

function postmap_files()
{
    for file in $@; do
        /usr/sbin/postmap $file
    done
}

# Anyway, we use install to write the files. We write special files that need
# stricter privileges before the glob of all files in the same directory.
install_files root 640 etc/postfix/sasl_passwd
install_files root 644 var/lib/unbound/etc/unbound/* \
                       etc/init/* \
                       etc/unbound/* \
                       etc/haproxy/* \
                       etc/selinux/targeted/contexts/users/* \
                       etc/postfix/*
install_files root 755 etc/rc.d/init.d/* \
                       usr/bin/*
install_files root 440 etc/sudoers.d/* \
                       etc/sudoers*
install_files root 600 etc/ssh/sshd_config

# Create postfix configuration databases.
postmap_files /etc/postfix/transport \
              /etc/postfix/sasl_passwd \
              /etc/postfix/authorized_submit_users \
              /etc/postfix/virtual_maps

# Create Puppy application log directory.
/bin/mkdir -p /var/log/puppy/apps /var/log/puppy/worker

# Create Puppy user policy generation directory.
/bin/mkdir -p /var/cache/puppy/policy /var/cache/puppy/transitions /var/cache/puppy/decommissioned

# Allow the worker to generate and compile the per-user SELinux policies.
/bin/chown worker:worker /var/cache/puppy/policy

# Create the puppy controlled mount points.
/bin/mkdir -p /puppy /node /opt
/bin/chown puppy:puppy /puppy /node /opt

# Create the puppy configuration directory.
/bin/mkdir -p /etc/puppy

# Configure agent home directories.
# -------------------------------------------------------------------------- #

function copy_public_key()
{
    local user=$1; local key=$2; local command=$3
    /usr/bin/sudo -u $user /bin/mkdir -p /home/$user/.ssh
    /bin/touch /home/$user/.ssh/authorized_keys
    /bin/chown $user:$user /home/$user/.ssh/authorized_keys
    /bin/chmod 600 /home/$user/.ssh/authorized_keys
    echo -n 'command="'$command'",no-port-forwarding,no-X11-forwarding,no-agent-forwarding,no-pty ' \
        > /home/$user/.ssh/authorized_keys
    /bin/cat $key >> /home/$user/.ssh/authorized_keys
}

# TODO Check the public key into source, but the keys do not live in source,
# they live on a server and propagate.
copy_public_key public home/public/ssh/authorized_keys /puppy/public/bin/public_receptionist

# We do not want the agent accounts to run `/etc/bashrc` at startup, and we do
# want them to find the right `node`, so replace the default `.bashrc` with our own.
for agent in public; do
    echo 'export PATH=$PATH:/opt/bin' > /home/$agent/.bashrc
    echo 'export NODE_PATH=/opt/lib/node:/puppy/common/lib/node' >> /home/$agent/.bashrc
done

# Configure daemons built from source.
# -------------------------------------------------------------------------- #

function on_boot()
{
    local service=$1
    until /sbin/chkconfig | /bin/grep "${service}.*3:on" > /dev/null; do
        /sbin/chkconfig --add $service
        /sbin/chkconfig $service on
        echo "Enabled service $service to start on boot. You should start it now."
    done
}

/bin/chown -R unbound /var/lib/unbound
on_boot unbound

if [ ! -e /etc/sasldb2 ]; then
    echo "Generating postfix localhost SMTP password."
    # Generate a password and assign it to a messages user.
    /bin/ps ax | /usr/bin/md5sum | /bin/cut -d' ' -f1 | \
        /usr/sbin/saslpasswd2 -c -u prettyrobots.com messages
    /bin/chown postfix:worker /etc/sasldb2
fi
on_boot postfix

# Set SELinux file contexts.
# -------------------------------------------------------------------------- #

/sbin/restorecon -R /puppy /etc /home /var/log/puppy /var/cache/puppy /node /opt
