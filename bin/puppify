#!/bin/bash

if [ $(whoami) != "root" ]; then
    echo "Must run as root." 1>&2
    exit 1
fi

# User and group generation.                                                            
# -------------------------------------------------------------------------- #
# User and group generation functions that check to see if the group already
# exists, followed by the invocation of the functions.
function make_group()
{
    group=$1
    gid=$2
    cut -d: -f1 /etc/group | grep '^'$group'$' > /dev/null
    ret=$?
    if [ $ret != 0 ]
    then
        echo "Creating group $group."
        /usr/sbin/groupadd --gid $gid $group
    fi
}

function make_user()
{
    user=$1
    uid=$2
    make_group $user $uid
    cut -d: -f1 /etc/passwd | grep '^'$user'$' > /dev/null
    ret=$?
    if [ $ret != 0 ]
    then
        echo "Creating user $user."
        /usr/sbin/useradd --uid $uid --gid $uid $user
    fi
}

# Users representing Puppy agents.
make_user   common        200
make_user   puppy         201
make_user   janitor       202
make_user   worker        204
make_user   database      205
make_user   system        207
make_user   vhosts        208
make_user   public        209
make_user   private       210
make_user   liminal       211
make_user   protected     212

# Users for built from source daemons.
make_user   haproxy       225
make_user   stunnel       226
make_user   unbound       228

# Make all of the workers member of the common group.
function group_assign()
{
    local group=$1; min=$2; local max=$3;
    while read line
    do
        user=($(echo $line | /bin/awk -F: '{ print $1, $3 }'))
        if [ "${user[1]}" -ge $min  -a "${user[1]}" -le $max ]; then
            members=$(/bin/grep "^${group}:" /etc/group | /bin/cut -d: -f4)
            if echo $members | /bin/grep -wv ${user[0]} > /dev/null; then
                echo "Adding ${user[0]} to group $group."
                /usr/sbin/usermod -G $group ${user[0]}
            fi
        fi
    done < /etc/passwd
}

group_assign common 201 220
exit 1 

# Configuration installtion
# -------------------------------------------------------------------------- #

# More the printing of the restart ssh message than for the preservation of the
# distribution's ssh_config.
if [ ! -e /etc/ssh/sshd_config.org ]; then
    /bin/mv /etc/ssh/sshd_config /etc/ssh/sshd_config.org
    echo "You must restart sshd."
fi

# git does not perserve file permissions, in case you forgot.
#  http://kerneltrap.org/mailarchive/git/2008/12/5/4327894

# Install a file if the source is newer than the currently installed file.
function install_file()
{
    local source=$1; local dest=$2; local owner=$3; local mode=$4
    file=$(basename $source)
    /bin/mkdir -p $dest
    dirty=0
    if [ -e $dest/$file ]; then
        if [ $(/usr/bin/stat --format=%Y $source) -gt $(/usr/bin/stat --format=%Y $dest/$file) ]; then
            dirty=1
        fi 
    else
        dirty=1
    fi
    if [ $dirty -eq 1 ]; then
        echo "Installing file $dest/$file."
        install -m $mode -g $owner -o $owner $source $dest/$file
    fi
}

# Install all files matching a glob.
function install_files()
{
    local ownership=$1; local mode=$2;
    shift; shift;
    for file in $@; do
        /bin/mkdir -m $mode -p $(dirname $file)
        install_file $file $(dirname /$file)  $ownership $mode
    done
}

function postmap_files()
{
    for file in $@; do
        /usr/sbin/postmap $file
    done
}

# Anyway, we use install to write the files. We write special files that need
# stricter privileges before the glob of all files in the same directory.
install_files root 640 etc/postfix/sasl_passwd
install_files root 644 var/lib/unbound/etc/unbound/* \
                       etc/init/* \
                       etc/unbound/* \
                       etc/haproxy/* \
                       etc/selinux/targeted/contexts/users/* \
                       etc/postfix/*
install_files root 755 etc/rc.d/init.d/* \
                       usr/bin/*
install_files root 440 etc/sudoers.d/*
install_files root 600 etc/ssh/sshd_config

# Create postfix configuration databases.
postmap_files /etc/postfix/transport /etc/postfix/sasl_passwd

# Create Puppy application log directory.
/bin/mkdir -p /var/log/puppy/apps /var/log/puppy/worker

# Create Puppy user policy generation directory.
/bin/mkdir -p /var/cache/puppy/policy /var/cache/puppy/transitions /var/cache/puppy/decommissioned

# Allow the worker to generate and compile the per-user SELinux policies.
/bin/chown worker:worker /var/cache/puppy/policy

# Create the puppy controlled mount points.
/bin/mkdir -p /puppy /node /opt
/bin/chown puppy:puppy /puppy /node /opt

# Create the puppy configuration directory.
/bin/mkdir -p /etc/puppy

# Configure agent home directories.
# -------------------------------------------------------------------------- #

function copy_public_key()
{
    local user=$1; local key=$2; local command=$3
    /usr/bin/sudo -u $user /bin/mkdir -p /home/$user/.ssh
    /bin/touch /home/$user/.ssh/authorized_keys
    /bin/chown $user:$user /home/$user/.ssh/authorized_keys
    /bin/chmod 600 /home/$user/.ssh/authorized_keys
    echo -n 'command="'$command'",no-port-forwarding,no-X11-forwarding,no-agent-forwarding,no-pty ' \
        > /home/$user/.ssh/authorized_keys
    /bin/cat $key >> /home/$user/.ssh/authorized_keys
}

# TODO Check the public key into source, but the keys do not live in source,
# they live on a server and propagate.
copy_public_key public home/public/ssh/authorized_keys /puppy/public/bin/public_receptionist

# We do not want the agent accounts to run `/etc/bashrc` at startup, and we do
# want them to find the right `node`, so replace the default `.bashrc` with our own.
for agent in public; do
    echo 'export PATH=$PATH:/opt/bin' > /home/$agent/.bashrc
done

# Add `/opt/bin` to the default secure path so that all sudoing will find
# the right node.
/bin/sed -ie 's/^\(Defaults \+secure_path = \).*/\1\/sbin:\/bin:\/usr\/sbin:\/usr\/bin:\/opt\/bin/' /etc/sudoers

# Configure daemons built from source.
# -------------------------------------------------------------------------- #

function on_boot()
{
    local service=$1
    until /sbin/chkconfig | /bin/grep "${service}.*3:on" > /dev/null; do
        /sbin/chkconfig --add $service
        /sbin/chkconfig $service on
        echo "Enabled service $service to start on boot. You should start it now."
    done
}

/bin/chown -R unbound /var/lib/unbound
on_boot unbound

if [ ! -e /etc/sasldb2 ]; then
    echo "Generating postfix localhost SMTP password."
    # Generate a password and assign it to a messages user.
    /bin/ps ax | /usr/bin/md5sum | /bin/cut -d' ' -f1 | \
        /usr/sbin/saslpasswd2 -c -u prettyrobots.com messages
    /bin/chown postfix:worker /etc/sasldb2
fi
on_boot postfix

# Set SELinux file contexts.
# -------------------------------------------------------------------------- #

/sbin/restorecon -R /puppy /etc /home /var/log/puppy /var/cache/puppy /node /opt
