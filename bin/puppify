#!/bin/bash

if [ $(whoami) != "root" ]; then
    echo "Must run as root." 1>&2
    exit 1
fi

function make_dir()
{
    directory=$1
    ownership=$2
    perms=$3
    if [ ! -e $directory ]
    then
        /bin/mkdir -p $directory
    fi
    /bin/chown $ownership $directory
    /bin/chmod $perms $directory
#    /sbin/restorecon -R $directory
}

function make_group()
{
    group=$1
    gid=$2
    cut -d: -f1 /etc/group | grep '^'$group'$' > /dev/null
    ret=$?
    if [ $ret != 0 ]
    then
        echo "Creating group $group."
        /usr/sbin/groupadd --gid $gid $group
    else
        echo "Group $group exists."
    fi
}

function make_user()
{
    user=$1
    uid=$2
    make_group $user $uid
    cut -d: -f1 /etc/passwd | grep '^'$user'$' > /dev/null
    ret=$?
    if [ $ret != 0 ]
    then
        echo "Creating user $user."
        /usr/sbin/useradd --uid $uid --gid $uid $user
    else
        echo "User $user exists."
    fi
}

# TODO Sort.

# Create the stunnel daemon user.
make_user public 209

# Create the stunnel daemon user.
make_user stunnel 206

# Create the vhosts daemon user.
make_user vhosts 208

# Create the worker daemon user.
make_user worker 204

# Create the system delegate user.
make_user   system  207

make_user private 210
make_user puppy 201
make_user janitor 202
make_user haproxy 203

make_user database 205

make_user liminal 211
make_user protected 212

make_user unbound 228

# Creates a directory tree by copying a directory tree, selecting the
# directories with a particular permissions setting.
function make_directories()
{
    path=$1
    prefix=$2
    perm=$3
    ownership=$4
    for file in $(/bin/find $path -type d -perm $perm | sort)
    do
        dest=$prefix$file
        if [ ! -e $dest ]
        then
            echo "Creating directory $dest."
            /bin/mkdir $dest
        fi
        /bin/chmod $perm $dest
        /bin/chown $ownership $dest
        /sbin/restorecon $dest
    done
}

# git does not perserve file permissions, in case you're wondering.
#  http://kerneltrap.org/mailarchive/git/2008/12/5/4327894
/bin/find var etc puppy -type d -exec /bin/chmod 755 {} \;
/bin/chmod 644 var/lib/unbound/etc/unbound/*
/bin/chmod 644 etc/init/*
/bin/chmod 644 etc/unbound/*
/bin/chmod 644 etc/haproxy/*
/bin/chmod 755 etc/rc.d/init.d/*
/bin/chmod 755 usr/bin/*
/bin/chmod 440 etc/sudoers.d/*
/bin/chmod 644 etc/selinux/targeted/contexts/users/*
/bin/chmod 600 etc/ssh/sshd_config

# Copy the etc and puppy directory structures.
make_directories etc / 755 root:root
make_directories var / 755 root:root

function copy_file()
{
    source=$1
    dest=$2
    ownership=$3
    mode=$4
    file=$(basename $source)
    /bin/mkdir -p $dest
    install=0
    if [ -e $dest/$file ]; then
        if [ $(/usr/bin/stat --format=%Y $source) -gt $(/usr/bin/stat --format=%Y $dest/$file) ]; then
            install=1
        fi 
    else
        install=1
    fi
    if [ $install -eq 1 ]; then
        echo "Installing file $dest/$file."
        /bin/cp $source $dest/$file
    fi
    /bin/chmod $mode $dest/$file
    if [ $(/usr/bin/stat --format=%A $source | /usr/bin/cut -c 4) == "-" ]; then
        /bin/chmod gou-x $dest/$file
    fi
    /bin/chown $ownership $dest/$file
}

function copy_files()
{
    dir=$1
    if [ -e $dir ]; then
        ownership=$2
        mode=$3
        for file in $(/bin/find $dir -type f -perm $mode); do
            copy_file $file $(dirname /$file)  $ownership $mode
        done
    fi
}

# Create the authorized_keys file that will launch /puppy/bin/public.
function copy_public_key()
{
    user=$1
    key=$2
    command=$3
    /usr/bin/sudo -u $user /bin/mkdir -p /home/$user/.ssh
    /bin/touch /home/$user/.ssh/authorized_keys
    /bin/chown $user:$user /home/$user/.ssh/authorized_keys
    /bin/chmod 600 /home/$user/.ssh/authorized_keys
    echo -n 'command="'$command'",no-port-forwarding,no-X11-forwarding,no-agent-forwarding,no-pty ' \
        > /home/$user/.ssh/authorized_keys
    /bin/cat $key >> /home/$user/.ssh/authorized_keys
}

# TODO Check the public key into source, but the keys do not live in source,
# they live on a server and propagate.
copy_public_key public home/public/ssh/authorized_keys /puppy/public/bin/public_receptionist

# Copy the etc configuration files.
copy_files etc root:root 644
copy_files etc root:root 440
copy_files etc root:root 755
copy_files usr root:root 755
copy_files var root:root 644

if [ ! -e /etc/ssh/sshd_config.org ]; then
    /bin/mv /etc/ssh/sshd_config /etc/ssh/sshd_config.org
    echo "You must restart sshd."
fi

copy_files etc root:root 600

# We do not want the agent accounts to run `/etc/bashrc` at startup, so delete
# the `~/.bashrc` files for those accounts.
for agent in public; do
    echo 'export PATH=$PATH:/opt/bin' > /home/$agent/.bashrc
done

# Create Puppy application log directory.
/bin/mkdir -p /var/log/puppy/apps /var/log/puppy/worker

# Create Puppy user policy generation directory.
/bin/mkdir -p /var/cache/puppy/policy /var/cache/puppy/transitions /var/cache/puppy/decommissioned

/bin/chown worker:worker /var/cache/puppy/policy

/bin/mkdir -p /puppy /node /opt
/bin/chown puppy:puppy /puppy /node /opt

/bin/chown -R unbound /var/lib/unbound

/sbin/chkconfig --add unbound
/sbin/chkconfig unbound on

/bin/sed -ie 's/^\(Defaults \+secure_path = \).*/\1\/sbin:\/bin:\/usr\/sbin:\/usr\/bin:\/opt\/bin/' /etc/sudoers

/bin/mkdir -p /etc/puppy

/sbin/restorecon -R /puppy /etc /home /var/log/puppy /var/cache/puppy /node /opt
