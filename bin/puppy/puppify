#!/bin/bash

if [ $(whoami) != "root" ]; then
    echo "Must run as root." 1>&2
    exit 1
fi

function abend()
{
    local message=$1;
    echo "ERROR: ${message}"
    exit 1
}

# Strip default Fedora cloud initialization scripts.
# -------------------------------------------------------------------------- #
# I used to spend some time pairing down images, but the Fedora cloud images are
# already spare. The only thing that must be removed is their `cloud-init`
# package. It has some dependencies that hare not needed, but we can learn live
# with those for now.

if /bin/rpm -qa | /bin/grep '^cloud-init'
then
    /usr/bin/yum erase -y cloud-init 
fi

# User and group generation.                                                            
# -------------------------------------------------------------------------- #
# User and group generation functions that check to see if the group already
# exists, followed by the invocation of the functions.
function make_group()
{
    local group=$1; local gid=$2
    current=$(/bin/grep "^${group}:" /etc/group | /bin/cut -d: -f3)
    if [ -z "$current" ]
    then
        echo "Creating group $group."
        /usr/sbin/groupadd --gid $gid $group
    elif [ "$current" != "$gid" ]
    then
        abend "Group $group exists with gid $current instead of $gid."
    fi
}

function make_user()
{
    local user=$1; local uid=$2;
    make_group $user $uid
    current=$(/bin/grep "^${user}:" /etc/passwd | /bin/cut -d: -f3)
    if [ -z "$current" ]
    then
        echo "Creating user $user."
        /usr/sbin/useradd --uid $uid --gid $uid $user
    elif [ "$current" != "$uid" ]
    then
        abend "User $user exists with uid $current instead of $uid."
    fi
}

# Users representing Puppy agents.
make_user   puppy         201
make_user   janitor       202
make_user   worker        204
make_user   database      205
make_user   system        207
make_user   vhosts        208
make_user   private       209
make_user   public        210
make_user   liminal       211
make_user   protected     212

# Users for built from source daemons.
make_user   haproxy       225
make_user   stunnel       226
make_group  loggers       227
make_user   common        229
make_user   exclusive     230
make_user   backup        231

# Make all of the workers member of the common group.
function group_assign()
{
    local group=$1; min=$2; local max=$3;
    while read line
    do
        user=($(echo $line | /bin/awk -F: '{ print $1, $3 }'))
        if [ "${user[1]}" -ge $min  -a "${user[1]}" -le $max ]; then
            members=$(/bin/grep "^${group}:" /etc/group | /bin/cut -d: -f4)
            if echo $members | /bin/grep -wv ${user[0]} > /dev/null; then
                echo "Adding ${user[0]} to group $group."
                /usr/sbin/usermod -a -G $group ${user[0]} || abend "Cannot add ${user[0]} to $group."
            fi
        fi
    done < /etc/passwd
}

group_assign exclusive 202 210
group_assign loggers 1  700
group_assign wheel 701 701
group_assign wheel 202 202

# Configuration installtion
# -------------------------------------------------------------------------- #

# More the printing of the restart ssh message than for the preservation of the
# distribution's ssh_config.
if [ ! -e /etc/ssh/sshd_config.org ]; then
    /bin/mv /etc/ssh/sshd_config /etc/ssh/sshd_config.org
    echo "You must restart sshd."
fi

# git does not perserve file permissions, in case you forgot.
#  http://kerneltrap.org/mailarchive/git/2008/12/5/4327894

# Install a file if the source is newer than the currently installed file.
function install_file()
{
    local source=$1; local dest=$2; local owner=$3; local mode=$4
    file=$(basename $source)
    /bin/mkdir -p $dest
    dirty=0
    if [ -e $dest/$file ]; then
        if [ $(/usr/bin/stat --format=%Y $source) -gt $(/usr/bin/stat --format=%Y $dest/$file) ]; then
            dirty=1
        fi 
    else
        dirty=1
    fi
    if [ $dirty -eq 1 ]; then
        echo "Installing file $dest/$file."
        install -m $mode -g $owner -o $owner $source $dest/$file
    fi
}

# Install all files matching a glob.
function install_files()
{
    local ownership=$1; local mode=$2;
    shift; shift;
    for file in $@; do
        /bin/mkdir -m $mode -p $(dirname $file)
        install_file $file $(dirname /$file)  $ownership $mode
    done
}

function postmap_files()
{
    for file in $@; do
        /usr/sbin/postmap $file
    done
}

# Anyway, we use install to write the files. We write special files that need
# stricter privileges before the glob of all files in the same directory.
install_files root 640 etc/postfix/sasl_passwd
install_files root 644 etc/unbound/* \
                       etc/haproxy/* \
                       etc/selinux/targeted/contexts/users/* \
                       etc/postfix/* \
                       etc/systemd/system/* \
                       etc/rsyslog.conf
install_files root 755 etc/rc.d/init.d/* \
                       usr/bin/*
install_files root 440 etc/sudoers.d/* \
                       etc/sudoers \
                       etc/sudoers.env
install_files root 600 etc/ssh/sshd_config
install_files root 700 root/configure.sh

# Make sure there is a place for unbound pid file.
/bin/mkdir -p /var/run/unbound

# Remove default rsyslog.service.
/bin/rm -f /lib/systemd/system/rsyslog.service

# Create a chroot directory for HAProxy.
/bin/mkdir -p /var/lib/haproxy
/bin/chown haproxy:haproxy /var/lib/haproxy

# Create postfix configuration databases.
postmap_files /etc/postfix/transport \
              /etc/postfix/sasl_passwd \
              /etc/postfix/authorized_submit_users \
              /etc/postfix/virtual_maps

# Create Puppy application log directory.
/bin/mkdir -p /var/log/puppy/apps /var/log/puppy/worker

# Create Puppy user policy generation directory.
/bin/mkdir -p /var/cache/puppy/policy /var/cache/puppy/transitions /var/cache/puppy/decommissioned

# Allow the worker to generate and compile the per-user SELinux policies.
/bin/chown worker:worker /var/cache/puppy/policy

# Create the puppy controlled mount points.
/bin/mkdir -p /puppy /node /opt
/bin/chown puppy:puppy /puppy /node /opt

# Create the puppy configuration directory.
/bin/mkdir -p /etc/puppy

# Configure agent home directories.
# -------------------------------------------------------------------------- #

function copy_public_key()
{
    local user=$1; local key=$2; local command=$3
    /usr/bin/sudo -u $user /bin/mkdir -p /home/$user/.ssh
    /bin/touch /home/$user/.ssh/authorized_keys
    /bin/chown $user:$user /home/$user/.ssh/authorized_keys
    /bin/chmod 600 /home/$user/.ssh/authorized_keys
    if [ ! -z $command ]; then
    echo -n 'command="'$command'",no-port-forwarding,no-X11-forwarding,no-agent-forwarding,no-pty ' \
        > /home/$user/.ssh/authorized_keys
    fi
    /bin/cat $key >> /home/$user/.ssh/authorized_keys
}

# TODO Check the public key into source, but the keys do not live in source,
# they live on a server and propagate.
copy_public_key public home/public/ssh/authorized_keys /puppy/public/bin/public_receptionist
janitor=$(/bin/awk -F : '$3 ~ /^701$/ { print $1 }' /etc/passwd)
copy_public_key puppy /home/$janitor/.ssh/authorized_keys


# We do not want the agent accounts to run `/etc/bashrc` at startup, and we do
# want them to find the right `node`, so replace the default `.bashrc` with our own.
#
# Note that public won't use the exclusive library, but the path assertion code
# we insert into every node executable expects it.
for agent in public; do
    echo 'export PATH=$PATH:/opt/bin' > /home/$agent/.bashrc
    echo 'export NODE_PATH=/opt/lib/node_modules:/puppy/common/lib/node:/puppy/exclusive/lib/node' \
        >> /home/$agent/.bashrc
done

# Configure daemons built from source.
# -------------------------------------------------------------------------- #

function on_boot()
{
    local service=$1
    until /bin/systemctl is-enabled $service.service 1>/dev/null 2>&1
    do
        /bin/systemctl enable $service.service
        echo "Enabled service $service to start on boot. You should start it now."
    done
}

on_boot unbound
on_boot postfix
on_boot ntpd
on_boot configuration

if [ "$(/bin/readlink /etc/localtime)" != "/usr/share/zoneinfo/UTC" ]
then
    echo "Setting timezone to UTC."
    /usr/bin/sudo /bin/ln -sf /usr/share/zoneinfo/UTC /etc/localtime
fi


if [ ! -e /home/backup/.ssh/authorized_keys ]
then
    /usr/bin/sudo /bin/mkdir -p /home/backup/.ssh
    /usr/bin/sudo /bin/cp $(/usr/bin/dirname $0)/../backup/id_backup.pub /home/backup/.ssh/authorized_keys
    /usr/bin/sudo /bin/chown -R backup:backup /home/backup
    /usr/bin/sudo /bin/chmod 600 /home/backup/.ssh/authorized_keys
fi

# Set SELinux file contexts.
# -------------------------------------------------------------------------- #

/sbin/restorecon -R /puppy /etc /home /var/log/puppy /var/cache/puppy /node /opt


# Start unbound after restarting systemd, so that the unbound log files go in
# their log file. Toggle the other services we've touched so far.
# -------------------------------------------------------------------------- #
/bin/systemctl restart rsyslog.service
/bin/systemctl start unbound.service
/bin/systemctl restart unbound.service
/bin/systemctl restart ntpd.service
/bin/systemctl restart postfix.service

/bin/systemctl --system daemon-reload

# Setup networking to use unbound DNS cache.
# -------------------------------------------------------------------------- #
/bin/sed -i '/^PEERDNS=/d' /etc/sysconfig/network-scripts/ifcfg-eth0 
echo "PEERDNS=no" >> /etc/sysconfig/network-scripts/ifcfg-eth0
echo "nameserver 127.0.0.1" > /etc/resolv.conf
