policy_module(worker,1.0.0)

require {
    type etc_t;
    type bin_t;
    role system_r;
    type private_exec_t;
    type puppy_password_t;
}

############################################################################
### Policy for `worker` daemon.
############################################################################

type worker_t;
type worker_exec_t;

type worker_tmp_t;
files_type(worker_tmp_t)

## -- Functions common to all private `bash` scripts. --
type private_functions_t;
files_type(private_functions_t)

## Daemonize.
init_daemon_domain(worker_t, worker_exec_t)

## Worker spool directory.
type worker_spool_t;
files_type(worker_spool_t)

## Node.js executable boilerplate.
# -- The JIT generates executable code in writable memory. --
allow worker_t self:process execmem;
# -- Ares DNS reads urandom for an encryption key it doesn't use. --
dev_read_urand(worker_t)
# -- Ares DNS reads `/etc/resolve.conf`. 
sysnet_read_config(worker_t)
# -- Read system page size from `/proc/meminfo`. 
kernel_read_system_state(worker_t)

allow worker_t worker_exec_t:lnk_file read_lnk_file_perms;

allow worker_t worker_spool_t:dir rw_dir_perms;
allow worker_t worker_spool_t:file manage_file_perms;

allow worker_t etc_t:file read_file_perms;

files_search_spool(worker_t)
logging_write_generic_logs(worker_t)


allow worker_t self:fifo_file rw_fifo_file_perms;

# Don't feel good about this. I'd rather the transition programs where not
# shell, since I don't want worker to be able to launch an interactive shell.
#
# However, many daemons are allowed to execute the shell_exec_t. Grep the
# references policy and you'll see Squid, PostreSQL, Apache, and Samba.
#corecmd_exec_shell(worker_t)
corecmd_exec_bin(worker_t)

# Logging via syslog.
logging_send_syslog_msg(worker_t)

#allow enqueue_t enqueue_exec_t:lnk_file read_lnk_file_perms;
#allow enqueue_agent_t enqueue_exec_t:lnk_file read_lnk_file_perms;

############################################################################
### Policy for `private user:invite`.
############################################################################

# Invite sending is performed as the worker user.
puppy_worker_medo_private(private_user_invite)

# Query MySQL.
mysql_tcp_connect(private_user_invite_job_t)
mysql_stream_connect(private_user_invite_job_t)
mysql_rw_db_sockets(private_user_invite_job_t)

# Read the MySQL password.
read_files_pattern(private_user_invite_job_t, puppy_password_t, puppy_password_t)

# Write to the syslog.
logging_send_syslog_msg(private_user_invite_job_t)

# Send email.
corenet_tcp_connect_smtp_port(private_user_invite_job_t)
sysnet_dns_name_resolve(private_user_invite_job_t)
miscfiles_read_localization(private_user_invite_job_t)
hostname_exec(private_user_invite_job_t)

############################################################################
### Policy for `private user:create`.
############################################################################

# User creation is performed as root.
puppy_worker_sudo_job(private_user_create)

# Read /etc/passwd to determine if the user already exists.
allow private_user_create_t etc_t:file read_file_perms;

# Transition to the exising user management policy.
usermanage_domtrans_useradd(private_user_create_t)

############################################################################
### Policy for `private user:policy`.
############################################################################

# User policy assignment is performed as root.
puppy_worker_sudo_job(private_user_policy)

# Execute semanage to assign the protected policy to the user.
seutil_run_semanage(private_user_policy_t, worker_r)
allow semanage_t private_user_policy_spawn_t:fifo_file rw_fifo_file_perms;

############################################################################
### Policy for `private user:harden`.
############################################################################

## Types and roles.
type private_user_harden_spawn_t;
type private_user_harden_exec_t;
type private_user_harden_t;

role system_r types private_user_harden_spawn_t;
role system_r types private_user_harden_t;

## -- Type of files used to define per-application policies. --
type private_policy_var_t;
files_type(private_policy_var_t)

## Application and transitions.
# -- Specify the spawn executable type. --
application_domain(private_user_harden_spawn_t, private_user_harden_exec_t)
# -- Specify the executable type. --
application_domain(private_user_harden_t, private_user_harden_exec_t)
# -- Transition into the executable domain. --
domtrans_pattern(worker_t, private_user_harden_exec_t, private_user_harden_spawn_t)
# -- Allow the domain to sudo. --
sudo_role_template(private_user_harden_spawn, system_r, private_user_harden_spawn_t)
# -- Transition back into executable domain after sudo. --
domtrans_pattern(private_user_harden_spawn_sudo_t, private_user_harden_exec_t, private_user_harden_t)
# -- Both `bash` reads `nsswitch.conf`and `/etc/passwd` apparently to configure
#       DNS lookups (via glibc). --
allow private_user_harden_t etc_t:file read_file_perms;

## -- Application is a shell program. --
corecmd_exec_shell(private_user_harden_t)
## -- The shell program calls utilities. --
corecmd_exec_bin(private_user_harden_t)
## -- Read the private library of functions. --
allow private_user_harden_t private_functions_t:file read_file_perms;

## -- Create temporary files to redirect stdout. --
#write_worker_temporary_files(private_user_harden)

## -- `bash` read system page size from `/proc/meminfo`. --
kernel_read_system_state(private_user_harden_t)

## Pipes.
## -- Allow sudo to pipe input and output. --
#allow private_user_harden_sudo_t worker_t:fifo_file rw_fifo_file_perms;
allow private_user_harden_t self:fifo_file rw_fifo_file_perms;
allow load_policy_t private_user_harden_t:fifo_file rw_fifo_file_perms;

## Files.
## -- Create new var directories. --
allow private_user_harden_t private_policy_var_t:file manage_file_perms;
allow private_user_harden_t self:process execmem;

seutil_run_semanage(private_user_harden_t, worker_r)
allow semanage_t worker_t:fifo_file rw_fifo_file_perms;
allow setfiles_t private_user_harden_t:fifo_file rw_fifo_file_perms;

dontaudit private_user_harden_spawn_sudo_t worker_t:fifo_file rw_fifo_file_perms;

allow private_user_harden_spawn_t self:process execmem;

#============= private_user_harden_spawn_t ==============
allow private_user_harden_spawn_t self:fifo_file read_fifo_file_perms;
allow private_user_harden_t private_user_harden_spawn_t:fifo_file read_fifo_file_perms;

#============= private_user_harden_t ==============
allow private_user_harden_t private_user_harden_spawn_t:fifo_file write_fifo_file_perms;
allow semanage_t private_user_harden_spawn_t:fifo_file rw_fifo_file_perms;

allow load_policy_t private_user_harden_spawn_t:fifo_file rw_fifo_file_perms;

# -- Node.js DNS reads urandom for an encryption key it doesn't use. --
dev_dontaudit_read_urand(private_user_harden_spawn_t)
# -- Both `bash` and `node` read nsswitch.conf, and `bash` reads `/etc/passwd`
#       apparently to configure DNS lookups (via glibc). --
allow private_user_harden_spawn_t etc_t:file read_file_perms;
# -- Both `bash` and `node` read system page size from `/proc/meminfo`. 
kernel_read_system_state(private_user_harden_spawn_t)

allow setfiles_t private_user_harden_spawn_t:fifo_file rw_fifo_file_perms;

sysnet_read_config(private_user_harden_spawn_t)

allow private_user_harden_t private_policy_var_t:dir manage_dir_perms;
allow private_user_harden_t private_policy_var_t:file manage_file_perms;
