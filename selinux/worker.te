# Policy module for for the worker daemon and utilities.
policy_module(worker,1.0.0)

require {
    type etc_t;
    type policy_src_t, policy_config_t;
    type ssh_home_t;
    type user_home_t;
    type bin_t;
    role system_r;
    type private_exec_t;
    type database_t;
    type puppy_t;
    type setfiles_exec_t;
}

# When we sudo to other roles.
role system_r types database_t;
role system_r types delegate_t;
puppy_delegate_roles(system_r)

############################################################################
### Policy for `job` program.
############################################################################
type worker_job_t;      # The domain of the job program.
type worker_job_exec_t; # The worker job executable type.


# Read and write the puppy spool directory.
files_search_spool(worker_job_t)
allow worker_job_t worker_spool_t:dir rw_dir_perms;
allow worker_job_t worker_spool_t:file manage_file_perms;

# Worker needs to execute puppy binaries.
puppy_exec_puppy_bin(worker_job_t)

# The `job` program is a Node.js program.
puppy_node_exec(worker_job_t)
application_domain(worker_job_t, worker_job_exec_t)
allow worker_job_t worker_job_exec_t:lnk_file read;
allow worker_job_t self:fifo_file rw_file_perms;

# Log succssful message enqueue.
logging_send_syslog_msg(worker_job_t)

############################################################################
### Policy for `worker` daemon.
############################################################################
type worker_t;          # The worker type.
type worker_exec_t;     # The worker executable type.

# Not in use, probably used with policy file generation.
type worker_tmp_t;
files_type(worker_tmp_t)

## -- Functions common to all private `bash` scripts. --
type private_functions_t;
files_type(private_functions_t)

## Daemonize.
init_daemon_domain(worker_t, worker_exec_t)

## Worker spool directory.
type worker_spool_t;
files_type(worker_spool_t)

# The worker daemon is a Node.js program.
puppy_node_exec(worker_t)
allow worker_t worker_exec_t:lnk_file read_lnk_file_perms;

# Worker needs to execute Puppy binaries.
puppy_exec_puppy_bin(worker_t)

allow worker_t worker_spool_t:dir rw_dir_perms;
allow worker_t worker_spool_t:file manage_file_perms;

allow worker_t etc_t:file read_file_perms;

files_search_spool(worker_t)
logging_write_generic_logs(worker_t)

allow worker_t self:fifo_file rw_fifo_file_perms;

# Don't feel good about this. I'd rather the transition programs where not
# shell, since I don't want worker to be able to launch an interactive shell.
#
# However, many daemons are allowed to execute the shell_exec_t. Grep the
# references policy and you'll see Squid, PostreSQL, Apache, and Samba.
#corecmd_exec_shell(worker_t)
corecmd_exec_bin(worker_t)

# Logging via syslog.
logging_send_syslog_msg(worker_t)

############################################################################
### Policy for `private user:invite`.
############################################################################

# Invite sending is performed as the worker user.
puppy_worker_job(private_user_invite)

puppy_sudo(private_user_invite_job)
role system_r types private_user_invite_job_sudo_t;
domtrans_pattern(private_user_invite_job_sudo_t, private_exec_t, delegate_t)
allow private_user_invite_job_sudo_t worker_t:fifo_file rw_fifo_file_perms;
allow delegate_t private_user_invite_job_t:fifo_file rw_fifo_file_perms;

# Query MySQL.
mysql_tcp_connect(private_user_invite_job_t)
mysql_stream_connect(private_user_invite_job_t)
mysql_rw_db_sockets(private_user_invite_job_t)

# Write to the syslog.
logging_send_syslog_msg(private_user_invite_job_t)

# Send email.
corenet_tcp_connect_smtp_port(private_user_invite_job_t)
sysnet_dns_name_resolve(private_user_invite_job_t)
miscfiles_read_localization(private_user_invite_job_t)
hostname_exec(private_user_invite_job_t)

############################################################################
### Policy for `private user:create`.
############################################################################

# User creation is performed as root.
puppy_job_sudo_root(private_user_create)

# Read /etc/passwd to determine if the user already exists.
allow private_user_create_t etc_t:file read_file_perms;

# Transition to the exising user management policy.
usermanage_domtrans_useradd(private_user_create_t)

############################################################################
### Policy for `user:group` job.
############################################################################

# User creation is performed as root.
puppy_job_sudo_root(private_user_group)

# Read /etc/passwd to determine if the user already exists.
allow private_user_group_t etc_t:file read_file_perms;

# Transition to the exising user management policy.
usermanage_domtrans_useradd(private_user_group_t)

############################################################################
### Policy for `user:restorecon`.
############################################################################
#
# Note that the `user:restorecon` command may not be able to relabel from
# anything to anything. It exists to apply the correct labels during 

# Run security context restoration as root.
puppy_job_sudo_root(private_user_restorecon)

#init_system_domain(private_user_restorecon_t, private_user_restorecon_exec_t)

# This resolves the error message from audit2allow that reads:
# 
#  This avc is a constraint violation.  You will need to add an attribute to
#  either the source or target type to make it work.
#
# Constraints are defined in
#  /home/alan/src/refpolicy/policy/constraints
#
# They are more rough stuff to do to a domain, limiting the transitions based
# on domination, expressing constraints based on types and attributes.
#
# This will apply the typeattribute can_change_object_identity, which allows
# the private_user_restorecon_exec_t to relabel.
domain_obj_id_change_exemption(private_user_restorecon_t)

# Run restorecon.
seutil_exec_setfiles(private_user_restorecon_t)
seutil_read_config(private_user_restorecon_t)
seutil_read_file_contexts(private_user_restorecon_t)

# DAC override describes the ability of root read and write files that root does
# not itself own. (TODO: Not sure what fowner is about, but it is in the same vein.)
allow private_user_restorecon_t self:capability { dac_override dac_read_search fowner };

# TODO: Not sure why this is necessary.
allow private_user_restorecon_t { default_context_t }:file read_file_perms;

# Allow relabeling from any type.
allow private_user_restorecon_t { file_type }:dir list_dir_perms;
relabelfrom_dirs_pattern(private_user_restorecon_t, { file_type }, { file_type })
relabelfrom_files_pattern(private_user_restorecon_t, { file_type }, { file_type })
relabelfrom_lnk_files_pattern(private_user_restorecon_t, { file_type }, { file_type })
relabelfrom_fifo_files_pattern(private_user_restorecon_t, { file_type }, { file_type })
relabelfrom_sock_files_pattern(private_user_restorecon_t, { file_type }, { file_type })

# For `unlabeled_t`.
kernel_relabelfrom_unlabeled_files(private_user_restorecon_t)

# Allow relabling to home, SSH types.
allow private_user_restorecon_t { user_home_t user_home_dir_t ssh_home_t }:dir relabelto;
allow private_user_restorecon_t { user_home_t ssh_home_t }:file relabelto;

# Check to see if SELinux is enforcing.
selinux_get_enforce_mode(private_user_restorecon_t)

# Read the home directory files and folders.
userdom_read_user_home_content_files(private_user_restorecon_t)

############################################################################
### Policy for `user:provision`.
############################################################################

# User creation is performed as root.
puppy_job_sudo_root(private_user_provision)

job_sudo_private(private_user_provision)

allow puppy_t private_user_provision_t:fifo_file rw_fifo_file_perms;

allow private_user_provision_t { home_root_t user_home_dir_t }:dir list_dir_perms;
allow private_user_provision_t user_home_dir_t:dir read_file_perms;

# Allow deletion of existing home directory.
allow private_user_provision_t user_home_dir_t:dir delete_dir_perms;

# Allow chown of home directory and DAC override for root.
allow private_user_provision_t self:capability { chown dac_override };

# Obliterate home directory.
userdom_manage_home_role(system_r, private_user_provision_t)
manage_dirs_pattern(private_user_provision_t, home_root_t, home_root_t)

# Chown needs to read `/etc/passwd`.
files_read_etc_files(private_user_provision_t)

# Execute hostname. 
hostname_exec(private_user_provision_t)

############################################################################
### Policy for `user:decommission`.
############################################################################

# User creation is performed as root.
puppy_job_sudo_root(private_user_decommission)

job_sudo_private(private_user_decommission)

allow puppy_t private_user_decommission_t:fifo_file rw_fifo_file_perms;

allow private_user_decommission_t { home_root_t user_home_dir_t }:dir list_dir_perms;
allow private_user_decommission_t user_home_dir_t:dir read_file_perms;

# Allow deletion of existing home directory.
allow private_user_decommission_t user_home_dir_t:dir delete_dir_perms;

# Allow chown of home directory and DAC override for root.
allow private_user_decommission_t self:capability { dac_override };

# Create cache files as puppy_cache_t.
puppy_manage_cache_files(private_user_decommission_t)

# Relocate the home directory.
allow private_user_decommission_t user_home_dir_t:dir { write rename reparent };
manage_dirs_pattern(private_user_decommission_t, home_root_t, home_root_t)

# Execute hostname. 
hostname_exec(private_user_decommission_t)

############################################################################
### Policy for `user:chown`.
############################################################################

# User creation is performed as root.
puppy_job_sudo_root(private_user_chown)

# Execute hostname. 
hostname_exec(private_user_chown_t)

# Run the private utility.
job_sudo_private(private_user_chown)

# Read user home directory files.
userdom_ro_home_role(system_r, private_user_chown_t)
ssh_read_user_home_files(private_user_chown_t)

# Allow root override of DAC and write of modes.
allow private_user_chown_t self:capability { chown dac_override };
allow private_user_chown_t user_home_t:dir setattr;
allow private_user_chown_t user_home_t:file setattr;
allow private_user_chown_t user_home_dir_t:dir setattr;
allow private_user_chown_t ssh_home_t:dir setattr;
allow private_user_chown_t ssh_home_t:file setattr;
allow private_user_chown_t home_root_t:dir setattr;

# Chown needs to read `/etc/passwd`.
files_read_etc_files(private_user_chown_t)

############################################################################
### Policy for `user:skel`.
############################################################################

# User creation is performed as root.
puppy_job_sudo_root(private_user_skel)

# Execute hostname. 
hostname_exec(private_user_skel_t)

# Run the private utility.
job_sudo_private(private_user_skel)

# Read user home directory files.
userdom_manage_home_role(system_r, private_user_skel_t)

# Read the `/etc/skel` files.
files_read_etc_files(private_user_skel_t)

# Write to directories owned by the intended user.
allow private_user_skel_t self:capability { dac_read_search dac_override };

############################################################################
### Policy for `user:authorize`.
############################################################################

# User creation is performed as root.
puppy_job_sudo_root(private_user_authorize)

# Execute hostname. 
hostname_exec(private_user_authorize_t)

# Run the private utility.
job_sudo_private(private_user_authorize)

# Allow root DAC override.
allow private_user_authorize_t self:capability dac_override;

# List the home directory.
files_search_home(private_user_authorize_t)

# Manage home directory, where the ssh files may be mislabeled.
userdom_manage_home_role(system_r, private_user_authorize_t)

# List the home directories.
#userdom_manage_user_home_dirs(private_user_authorize_t)

domtrans_pattern(private_user_authorize_t, private_exec_t, delegate_t)

############################################################################
### Policy for `private user:policy`.
############################################################################

# User policy assignment is performed as root.
puppy_job_sudo_root(private_user_policy)

# Execute semanage to assign the protected policy to the user.
seutil_run_semanage(private_user_policy_t, worker_r)
allow semanage_t private_user_policy_proxy_t:fifo_file rw_fifo_file_perms;

# Get some output.
allow setfiles_t private_user_policy_proxy_t:fifo_file { read write };
allow load_policy_t private_user_policy_proxy_t:fifo_file { read write };

# Allow script to create a temporary file for here-doc.
type private_user_policy_tmp_t;
files_tmp_file(private_user_policy_tmp_t)
manage_files_pattern(private_user_policy_t, private_user_policy_tmp_t, private_user_policy_tmp_t)
files_tmp_filetrans(private_user_policy_t, private_user_policy_tmp_t, file)

# This allows the reading of fielsystem extended attributes. It is triggered by
# the bash here-doc syntax. My guess is that the temp file creation checks for
# available disk space prior to creating the temp file. 
fs_getattr_xattr_fs(private_user_policy_t)

# Read the Makefile.
files_read_usr_files(private_user_policy_t)

# Make runs the shell.
corecmd_exec_shell(private_user_policy_t)

# Read and SELinux properties during build.
selinux_get_enforce_mode(private_user_policy_t)
seutil_search_default_contexts(private_user_policy_t)
seutil_read_config(private_user_policy_t)

# Create cache files as puppy_cache_t.
puppy_manage_cache_files(private_user_policy_t)

# Read and write the database.
job_sudo_private(private_user_policy)

# Read the hostname.
hostname_exec(private_user_policy_t)

############################################################################
### Policy for `private user:port`.
############################################################################

# User port assignment is performed as root.
puppy_job_sudo_root(private_user_port)

type filter_selinux_ports_exec_t;

application_domain(private_user_port_t, filter_selinux_ports_exec_t)

allow private_user_port_t filter_selinux_ports_exec_t:file execute_no_trans;

# Execute semanage to assign the protected port to the user.
seutil_run_semanage(private_user_port_t, worker_r)
allow semanage_t private_user_port_proxy_t:fifo_file rw_fifo_file_perms;

# Read and write the database.
job_sudo_private(private_user_port)

# Read the hostname.
hostname_exec(private_user_port_t)

############################################################################
### Policy for `private user:config`.
############################################################################

# User config assignment is performed as root.
puppy_job_sudo_root(private_user_config)

# Execute semanage to assign the protected port to the user.
seutil_run_semanage(private_user_config_t, worker_r)
allow semanage_t private_user_config_proxy_t:fifo_file rw_fifo_file_perms;

# Create the configuration directories.
userdom_manage_home_role(system_r, private_user_config_t)

puppy_read_puppy_etc(private_user_config_t)

# Read the network state.
allow private_user_config_t self:capability { dac_read_search dac_override };

# Read and write the database.
job_sudo_private(private_user_config)
