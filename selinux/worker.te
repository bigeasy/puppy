# Policy module for for the worker daemon and utilities.
policy_module(worker,1.0.0)

require {
    type etc_t;
    type policy_src_t, policy_config_t;
    type ssh_home_t;
    type user_home_t;
    type home_bin_t;
    type bin_t;
    type database_exec_t;
    type database_t;
    role system_r;
    type database_t;
    type puppy_t;
    type setfiles_exec_t;
    attribute puppy_daemon_log_type;
    attribute puppy_daemon_exec_type;
}

# When we sudo to other roles.
puppy_postgresql(worker_t)
hostname_exec(worker_t)

# This was added after the switch to systemd, probably to stream to syslog.
init_rw_stream_sockets(worker_t)

type janitor_mysql_t;
type janitor_mysql_exec_t;
application_domain(janitor_mysql_t, janitor_mysql_exec_t)

puppy_sudo(worker)
role system_r types worker_sudo_t;
role system_r types worker_t;

domtrans_pattern(worker_sudo_t, database_exec_t, database_t)
allow database_t worker_t:fifo_file rw_fifo_file_perms;

############################################################################
### Policy for `worker` daemon.
############################################################################
type worker_t;          # The worker type.
type worker_exec_t;     # The worker executable type.

# Not in use, probably used with policy file generation.
type worker_tmp_t;
files_type(worker_tmp_t)

## -- Functions common to all private `bash` scripts. --
type private_functions_t;
files_type(private_functions_t)

puppy_try_catch(worker)

## Daemonize.
init_daemon_domain(worker_try_t, worker_try_exec_t)

# The worker daemon is a Node.js program.
puppy_node_exec(worker_t)
allow worker_t worker_exec_t:lnk_file read_lnk_file_perms;

# Worker needs to execute Puppy binaries.
puppy_exec_puppy_bin(worker_t)
allow worker_t worker_exec_t:file execute_no_trans;

allow worker_t etc_t:file read_file_perms;

files_search_spool(worker_t)
logging_write_generic_logs(worker_t)

allow worker_t self:fifo_file rw_fifo_file_perms;

# Don't feel good about this. I'd rather the transition programs where not
# shell, since I don't want worker to be able to launch an interactive shell.
#
# However, many daemons are allowed to execute the shell_exec_t. Grep the
# references policy and you'll see Squid, PostreSQL, Apache, and Samba.
#corecmd_exec_shell(worker_t)
corecmd_exec_bin(worker_t)

# Logging via syslog.
logging_send_syslog_msg(worker_t)

############################################################################
### Policy for `account_ready`.
############################################################################

# Invite sending is performed as the worker user.
puppy_job_as_worker(account_ready)

job_sudo_system(account_ready)
job_system_trans(account_ready, account_ready)

############################################################################
### Policy for `app_reconfig`.
############################################################################

# Invite sending is performed as the worker user.
puppy_job_as_worker(app_reconfig)

job_sudo_system(app_reconfig)
job_system_trans(app_reconfig, app_reconfig)

############################################################################
### Policy for `daemon_start`.
############################################################################

puppy_job_as_root(daemon_start)

allow daemon_start_job_t init_t:unix_stream_socket connectto;

############################################################################
### Policy for `daemon_stop`.
############################################################################

puppy_job_as_root(daemon_stop)

allow daemon_stop_job_t init_t:unix_stream_socket connectto;
files_read_etc_files(daemon_stop_job_t)

############################################################################
### Policy for `init_generate`.
############################################################################
#
# Note that the `init_generate` command may not be able to relabel from
# anything to anything. It exists to apply the correct labels during 

# Run security context restoration as root.
puppy_job_as_root(init_generate)

# Allow script to create a temporary file for here-doc.
type init_generate_job_tmp_t;
files_tmp_file(init_generate_job_tmp_t)
manage_files_pattern(init_generate_job_t, init_generate_job_tmp_t, init_generate_job_tmp_t)
files_tmp_filetrans(init_generate_job_t, init_generate_job_tmp_t, file)

# This allows the reading of fielsystem extended attributes. It is triggered by
# the bash here-doc syntax. My guess is that the temp file creation checks for
# available disk space prior to creating the temp file. 
fs_getattr_xattr_fs(init_generate_job_t)

allow init_generate_job_t { puppy_daemon_exec_type puppy_daemon_log_type }:file manage_file_perms;
allow init_generate_job_t { puppy_daemon_log_type }:dir manage_dir_perms;

# Allow chown of home directory and DAC override for root.
allow init_generate_job_t self:capability { fsetid fowner chown dac_override };

# Write the etc init files.
allow init_generate_job_t etc_t:file manage_file_perms;
allow init_generate_job_t etc_t:dir manage_dir_perms;

# Write the transition program.
allow init_generate_job_t puppy_cache_t:dir manage_dir_perms;
allow init_generate_job_t puppy_cache_t:file manage_file_perms;

# Create the log directory and files.
allow init_generate_job_t var_log_t:dir manage_dir_perms;
allow init_generate_job_t var_log_t:file manage_file_perms;

############################################################################
### Policy for `init_restorecon`.
############################################################################
#
# Note that the `init_restorecon` command may not be able to relabel from
# anything to anything. It exists to apply the correct labels during 

# Run security context restoration as root.
puppy_job_as_root(init_restorecon)

# Run restorecon.
seutil_domtrans_setfiles(init_restorecon_job_t)

allow setfiles_t init_restorecon_job_proxy_t:fifo_file rw_fifo_file_perms;

allow init_restorecon_job_t puppy_cache_t:dir list_dir_perms;
allow init_restorecon_job_t var_log_t:dir list_dir_perms;
allow init_restorecon_job_t file_type:dir getattr;
allow init_restorecon_job_t file_type:file getattr;

############################################################################
### Policy for `mysql_create`.
############################################################################

puppy_job_as_root(mysql_create)

job_sudo_system(mysql_create)
job_system_trans(mysql_create, db_password)

domtrans_pattern(mysql_create_job_sudo_t, janitor_mysql_exec_t, janitor_mysql_t)

# FIXME Write why you to this, to have a place with minimal MySQL policy.
role system_r types janitor_mysql_t;
allow janitor_mysql_t mysql_create_job_proxy_t:fifo_file rw_fifo_file_perms;
allow janitor_mysql_t mysql_create_job_t:fifo_file rw_fifo_file_perms;

puppy_postgresql(janitor_mysql_t)

puppy_exec_puppy_sbin(janitor_mysql_t)
corecmd_exec_bin(janitor_mysql_t)

allow mysql_create_job_t self:capability { dac_read_search dac_override };

files_read_usr_files(janitor_mysql_t)
files_read_etc_files(janitor_mysql_t)
files_search_home(janitor_mysql_t)
kernel_read_system_state(janitor_mysql_t)
mysql_read_config(janitor_mysql_t)
userdom_list_user_home_dirs(janitor_mysql_t)
userdom_read_user_home_content_files(janitor_mysql_t)

allow janitor_mysql_t worker_t:fifo_file write;

############################################################################
### Policy for `mysql_grant`.
############################################################################

puppy_job_as_root(mysql_grant)

job_sudo_system(mysql_grant)
job_system_trans(mysql_grant, db_password)
job_system_trans(mysql_grant, app_users)

allow janitor_mysql_t mysql_grant_job_t:fifo_file rw_fifo_file_perms;
allow janitor_mysql_t mysql_grant_job_proxy_t:fifo_file rw_fifo_file_perms;

domtrans_pattern(mysql_grant_job_sudo_t, janitor_mysql_exec_t, janitor_mysql_t)

############################################################################
### Policy for `user_policy`.
############################################################################
#
type user_policy_job_exec_t;

############################################################################
### Policy for `policy_generate`.
############################################################################

puppy_job_as_worker(policy_generate)

job_sudo_system(policy_generate)
job_system_trans(policy_generate, policy_users)

# Pass host name to system utilities.
hostname_exec(policy_generate_job_t)

# Create cache files as puppy_cache_t.
puppy_manage_cache_files(policy_generate_job_t)

# Execute the `/puppy/worker/sbin/user_policy` helper program.
allow policy_generate_job_t policy_generate_job_exec_t:file execute_no_trans;
application_domain(policy_generate_job_t, user_policy_job_exec_t)
allow policy_generate_job_t user_policy_job_exec_t:file execute_no_trans;

# Allow script to create a temporary file for here-doc.
type policy_generate_job_tmp_t;
files_tmp_file(policy_generate_job_tmp_t)
manage_files_pattern(policy_generate_job_t, policy_generate_job_tmp_t, policy_generate_job_tmp_t)
files_tmp_filetrans(policy_generate_job_t, policy_generate_job_tmp_t, file)

# This allows the reading of fielsystem extended attributes. It is triggered by
# the bash here-doc syntax. My guess is that the temp file creation checks for
# available disk space prior to creating the temp file. 
fs_getattr_xattr_fs(policy_generate_job_t)

############################################################################
### Policy for `policy_load`.
############################################################################

# User policy assignment is performed as root.
puppy_job_as_root(policy_load)

job_sudo_system(policy_load)
job_system_trans(policy_load, policy_users)

miscfiles_read_localization(policy_load_job_t)

# Execute semanage to assign the protected policy to the user.
seutil_run_semanage(policy_load_job_t, worker_r)
allow semanage_t policy_load_job_proxy_t:fifo_file rw_fifo_file_perms;

# Pass host name to `policy_users`.
hostname_exec(policy_load_job_t)

# Allow output to the worker daemon.
puppy_rw_worker_fifo(setfiles_t, policy_load)
puppy_rw_worker_fifo(load_policy_t, policy_load)

# Read and SELinux properties during build.
selinux_get_enforce_mode(policy_load_job_t)
seutil_search_default_contexts(policy_load_job_t)
seutil_read_config(policy_load_job_t)

# Create cache files as puppy_cache_t.
puppy_read_cache_files(policy_load_job_t)

############################################################################
### Policy for `policy_make`.
############################################################################

puppy_job_as_worker(policy_make)

job_sudo_system(policy_make)
job_system_trans(policy_make, policy_users)


# Pass host name to `user_policy`.
hostname_exec(policy_make_job_t)

# Create cache files as puppy_cache_t.
puppy_manage_cache_files(policy_make_job_t)

# Read the Makefile.
files_read_usr_files(policy_make_job_t)

# Execute the `/puppy/sbin/user_policy`.
# DUBIOUS: allow policy_make_job_t policy_make_job_exec_t:file execute_no_trans;

selinux_get_enforce_mode(policy_make_job_t)
seutil_read_config(policy_make_job_t)
seutil_search_default_contexts(policy_make_job_t)

############################################################################
### Policy for `user_config`.
############################################################################

# User config assignment is performed as root.
puppy_job_as_root(user_config)

job_sudo_system(user_config)
job_system_trans(user_config, app_config)
job_system_trans(user_config, mysql_config)

# Execute semanage to assign the protected port to the user.
seutil_run_semanage(user_config_job_t, worker_r)
allow semanage_t user_config_job_proxy_t:fifo_file rw_fifo_file_perms;

# Create the configuration directories.
userdom_manage_home_role(system_r, user_config_job_t)

puppy_read_puppy_etc(user_config_job_t)

# Read the network state.
allow user_config_job_t self:capability { dac_read_search dac_override };

hostname_exec(user_config_job_t)

############################################################################
### Policy for `app_deploy`.
############################################################################

# Run security context restoration as root.
puppy_job_as_root(app_deploy)

allow app_deploy_job_t self:capability { dac_override };

# Copy the files from staging to application.
userdom_manage_home_role(system_r, app_deploy_job_t)

# Run `rsync`.
rsync_exec(app_deploy_job_t)
files_read_etc_files(app_deploy_job_t)
allow app_deploy_job_t self:process signal;

allow app_deploy_job_t self:capability { fowner chown };

############################################################################
### Policy for `user_group` job.
############################################################################

# User creation is performed as root.
puppy_job_as_root(user_group)

# Read /etc/passwd to determine if the user already exists.
allow user_group_job_t etc_t:file read_file_perms;

# Transition to the exising user management policy.
usermanage_domtrans_useradd(user_group_job_t)

############################################################################
### Policy for `user_invite`.
############################################################################

# Invite sending is performed as the worker user.
puppy_job_as_worker(user_invite)

job_sudo_system(user_invite)
job_system_trans(user_invite, user_activation)

puppy_node_exec(user_invite_job_t)

# Write to the syslog.
logging_send_syslog_msg(user_invite_job_t)

# Send email.
mta_send_mail(user_invite_job_t)

############################################################################
### Policy for `user_provision`.
############################################################################

# User creation is performed as root.
puppy_job_as_root(user_provision)

# DUBIOUS allow puppy_t user_provision_t:fifo_file rw_fifo_file_perms;

allow user_provision_job_t { home_root_t user_home_dir_t }:dir list_dir_perms;
allow user_provision_job_t user_home_dir_t:dir read_file_perms;

# Allow deletion of existing home directory.
allow user_provision_job_t user_home_dir_t:dir delete_dir_perms;

# Allow chown of home directory and DAC override for root.
allow user_provision_job_t self:capability { chown dac_override };

# Obliterate home directory.
userdom_manage_home_role(system_r, user_provision_job_t)
manage_dirs_pattern(user_provision_job_t, home_root_t, home_root_t)

# Chown needs to read `/etc/passwd`.
files_read_etc_files(user_provision_job_t)

############################################################################
### Policy for `user_ready`.
############################################################################

# User policy assignment is performed as root.
puppy_job_as_worker(user_ready)

job_sudo_system(user_ready)
job_system_trans(user_ready, user_ready)

hostname_exec(user_ready_job_t)

############################################################################
### Policy for `policy_ready`.
############################################################################

# User policy assignment is performed as root.
puppy_job_as_worker(policy_ready)

job_sudo_system(policy_ready)
job_system_trans(policy_ready, policy_users)
job_system_trans(policy_ready, policy_ready)

# Execute semanage to assign the protected policy to the user.
seutil_run_semanage(policy_ready_job_t, worker_r)
allow semanage_t policy_ready_job_proxy_t:fifo_file rw_fifo_file_perms;

# Pass host name to `policy_users`.
hostname_exec(policy_ready_job_t)

############################################################################
### Policy for `user_skel`.
############################################################################

# User creation is performed as root.
puppy_job_as_root(user_skel)

# Execute hostname. 
hostname_exec(user_skel_job_t)

# Read user home directory files.
userdom_manage_home_role(system_r, user_skel_job_t)

# Read the `/etc/skel` files.
files_read_etc_files(user_skel_job_t)

# Write to directories owned by the intended user.
allow user_skel_job_t self:capability { dac_read_search dac_override };

############################################################################
### Policy for `policy_unload`.
############################################################################

# User policy assignment is performed as root.
puppy_job_as_root(policy_unload)

# List the machine users in the system database.
job_sudo_system(policy_unload)
job_system_trans(policy_unload, policy_users)

# Execute semanage to assign the protected policy to the user.
seutil_run_semanage(policy_unload_job_t, worker_r)
allow semanage_t policy_unload_job_proxy_t:fifo_file rw_fifo_file_perms;

# Allow output to the worker daemon.
puppy_rw_worker_fifo(setfiles_t, policy_unload)
puppy_rw_worker_fifo(load_policy_t, policy_unload)

# Read and SELinux properties during build.
selinux_get_enforce_mode(policy_unload_job_t)
seutil_search_default_contexts(policy_unload_job_t)
seutil_read_config(policy_unload_job_t)

# Create cache files as puppy_cache_t.
puppy_read_cache_files(policy_unload_job_t)

# Get the hostname.
hostname_exec(policy_unload_job_t)

############################################################################
### Policy for `port_labelify`.
############################################################################

type port_labelify_job_exec_t;

############################################################################
### Policy for `port_label`.
############################################################################

# User policy assignment is performed as root.
puppy_job_as_root(port_label)

job_sudo_system(port_label)
job_system_trans(port_label, port_list)

# As of Fedora 15, Perl wants to touch `urandom` and read localization files.
dev_read_urand(port_label_job_t)
miscfiles_read_localization(port_label_job_t)

# Execute semanage to assign the protected policy to the user.
seutil_run_semanage(port_label_job_t, worker_r)
allow semanage_t port_label_job_proxy_t:fifo_file rw_fifo_file_perms;

# Get some output.
puppy_rw_worker_fifo(setfiles_t, port_label)
puppy_rw_worker_fifo(load_policy_t, port_label)

# Read and SELinux properties during build.
selinux_get_enforce_mode(port_label_job_t)
seutil_search_default_contexts(port_label_job_t)
seutil_read_config(port_label_job_t)

# Allow script to create a temporary file for here-doc.
type port_label_job_tmp_t;
files_tmp_file(port_label_job_tmp_t)
manage_files_pattern(port_label_job_t, port_label_job_tmp_t, port_label_job_tmp_t)
files_tmp_filetrans(port_label_job_t, port_label_job_tmp_t, file)

# This allows the reading of fielsystem extended attributes. It is triggered by
# the bash here-doc syntax. My guess is that the temp file creation checks for
# available disk space prior to creating the temp file. 
fs_getattr_xattr_fs(port_label_job_t)

# Read Perl libraries.
files_read_usr_files(port_label_job_t)

# Get the hostname.
hostname_exec(port_label_job_t)

# Execute `port_labelify`.
application_domain(port_label_job_t, port_labelify_job_exec_t)
allow port_label_job_t port_labelify_job_exec_t:file execute_no_trans;

############################################################################
### Policy for `port_unlabel`.
############################################################################

# User policy assignment is performed as root.
puppy_job_as_root(port_unlabel)

job_sudo_system(port_unlabel)
job_system_trans(port_unlabel, port_list)

# Execute semanage to assign the protected policy to the user.
seutil_run_semanage(port_unlabel_job_t, worker_r)

# As of Fedora 15, Perl wants to touch `urandom` and read localization files.
dev_read_urand(port_unlabel_job_t)
miscfiles_read_localization(port_unlabel_job_t)

# The semanage may report some errors to our proxy.

# Get some output.
puppy_rw_worker_fifo(setfiles_t, port_unlabel)
puppy_rw_worker_fifo(load_policy_t, port_unlabel)

# Execute semanage to assign the protected policy to the user. Allow semanage to
# write any errors to the stderr of the proxy.
seutil_run_semanage(port_unlabel_job_t, worker_r)
puppy_rw_worker_fifo(semanage_t, port_unlabel)

# Read and SELinux properties during build.
selinux_get_enforce_mode(port_unlabel_job_t)
seutil_search_default_contexts(port_unlabel_job_t)
seutil_read_config(port_unlabel_job_t)

# Allow script to create a temporary file for here-doc.
type port_unlabel_job_tmp_t;
files_tmp_file(port_unlabel_job_tmp_t)
manage_files_pattern(port_unlabel_job_t, port_unlabel_job_tmp_t, port_unlabel_job_tmp_t)
files_tmp_filetrans(port_unlabel_job_t, port_unlabel_job_tmp_t, file)

# This allows the reading of fielsystem extended attributes. It is triggered by
# the bash here-doc syntax. My guess is that the temp file creation checks for
# available disk space prior to creating the temp file. 
fs_getattr_xattr_fs(port_unlabel_job_t)

# Read Perl libraries.
files_read_usr_files(port_unlabel_job_t)

# Get the hostname.
hostname_exec(port_unlabel_job_t)

# Execute `port_labelify`.
application_domain(port_unlabel_job_t, port_labelify_job_exec_t)
allow port_unlabel_job_t port_labelify_job_exec_t:file execute_no_trans;

############################################################################
### Policy for `user_authorize`.
############################################################################

# User creation is performed as root.
puppy_job_as_root(user_authorize)

job_sudo_system(user_authorize)
job_system_trans(user_authorize, user_keys)

# Execute hostname. 
hostname_exec(user_authorize_job_t)

# Allow root DAC override.
allow user_authorize_job_t self:capability dac_override;

# List the home directory.
files_search_home(user_authorize_job_t)

# Manage home directory, where the ssh files may be mislabeled.
userdom_manage_home_role(system_r, user_authorize_job_t)

# List the home directories.
#userdom_manage_user_home_dirs(user_authorize_t)

#domtrans_pattern(user_authorize_t, private_exec_t, delegate_t)

############################################################################
### Policy for `user_chown`.
############################################################################

# User creation is performed as root.
puppy_job_as_root(user_chown)

# Execute hostname. 
hostname_exec(user_chown_job_t)

# Read user home directory files.
userdom_manage_home_role(system_r, user_chown_job_t)
ssh_read_user_home_files(user_chown_job_t)

allow user_chown_job_t self:capability { dac_read_search dac_override chown };

# Chown needs to read `/etc/passwd`.
files_read_etc_files(user_chown_job_t)

############################################################################
### Policy for `user_create` job.
############################################################################

# User creation is performed as root.
puppy_job_as_root(user_create)

# Read /etc/passwd to determine if the user already exists.
allow user_create_job_t etc_t:file read_file_perms;

# Transition to the exising user management policy.
usermanage_domtrans_useradd(user_create_job_t)

############################################################################
### Policy for `user_decommission`.
############################################################################

# User creation is performed as root.
puppy_job_as_root(user_decommission)

# DUBIOUS allow puppy_t user_decommission_t:fifo_file rw_fifo_file_perms;

allow user_decommission_job_t { home_root_t user_home_dir_t }:dir list_dir_perms;
allow user_decommission_job_t user_home_dir_t:dir read_file_perms;

# Allow deletion of existing home directory.
allow user_decommission_job_t user_home_dir_t:dir delete_dir_perms;

# Allow chown of home directory and DAC override for root.
allow user_decommission_job_t self:capability { dac_override };

# Create cache files as puppy_cache_t.
puppy_manage_cache_files(user_decommission_job_t)

# Relocate the home directory.
allow user_decommission_job_t user_home_dir_t:dir { write rename reparent };
manage_dirs_pattern(user_decommission_job_t, home_root_t, home_root_t)

############################################################################
### Policy for `user_restorecon`.
############################################################################
#
# Note that the `user_restorecon` command may not be able to relabel from
# anything to anything. It exists to apply the correct labels during 

# Run security context restoration as root.
puppy_job_as_root(user_restorecon)

# Run restorecon.
seutil_domtrans_setfiles(user_restorecon_job_t)

puppy_rw_worker_fifo(setfiles_t, user_restorecon)
