#!/bin/bash

function is_dirty()
{
    local source=$1; local dest=$2;
    if [ ! -e $dest ] || [ $(/usr/bin/stat --format=%Y $source) -gt $(/usr/bin/stat --format=%Y $dest) ]
    then
        return 0
    else
        return 1
    fi
}

function abend()
{
    message=$1
    echo -n "ERROR: $message"
    exit 1
}

function assert_valid_user()
{
    user=$1
    digit='^[0-9]+$'
    if [[ ! ($user =~ $digit) ]]; then
        abend "Incorrect parameter. Single UID parameter expected."
    fi

    if [ $user -lt 10001 -o $user -gt 100000000 ]; then
        abend "Puppy user id value $user is out of range."
    fi
}

function assert_valid_home_dir()
{
    uid=$1
    if [ ! -d /home/u$uid ]; then
        abend "Home directory /home/u$uid does not exist."
    fi
}

# Write output to a temporary file, then write the temperary file to stdout.
# This prevents the child process from inheriting the stdin, stdout, and stderr
# of the parent.
function redirect()
{
    command=$1
    shift
    $($command $@ 0>&- >/var/run/puppy/tmp/$$.out 2>/var/run/puppy/tmp/$$.err)
    /bin/cat /var/run/puppy/tmp/$$.out
    /bin/cat /var/run/puppy/tmp/$$.err 1>&2
    /bin/rm /var/run/puppy/tmp/$$.out
    /bin/rm /var/run/puppy/tmp/$$.err
}

function normalize_path()
{
    local path=$1
    while [[ $path =~ \/\.\/ ]]; do
    # Remove all /./ sequences.
        path=${path//\/\.\//\/}
    done
    
    while [[ $path =~ \/\/ ]]; do
    # Remove all /./ sequences.
        path=${path//\/\//\/}
    done

    # Remove dir/.. sequences.
    while [[ $path =~ ([^/][^/]*/\.\./) ]]
    do
        path=${path/${BASH_REMATCH[0]}/}
    done

    # See if there is a /. at the end of the string.
    path=${path/%\/\./}

    echo $path
}
