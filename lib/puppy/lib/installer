#!/bin/bash

function install_service() {
  local package="$1"
  if ! /bin/rpm -q "$package" > /dev/null
  then
      /usr/bin/sudo /usr/bin/yum install -y "$package" || abend "Cannot install $package."
      group_assign loggers 1  700
  fi
}

function service_dir() {
  local package=$(/bin/basename $0 | /bin/sed 's/^.*-\(.*\)$/\1/')
  echo "$PUPPIFY_PATH/share/service/postfix"
}
# git does not perserve file permissions, in case you forgot.
#  http://kerneltrap.org/mailarchive/git/2008/12/5/4327894

# Install a file if the source is newer than the currently installed file.
function install_file() {
  local source=$1; local dest=$2; local owner=$3; local mode=$4
  file=$(basename $source)
  /bin/mkdir -p $dest
  dir=$(service_dir)
  if /usr/bin/sudo [ \( ! -e $dest/$file \) -o  "$dir/$source" -nt $dest/$file ]; then
    echo "Installing file $dest/$file."
    /usr/bin/sudo install -m $mode -g $owner -o $owner "$dir/$source" $dest/$file
  fi
}

# Install all files matching a glob.
function install_files() {
  local ownership=$1; local mode=$2;
  shift; shift;
  for path in $@; do
    /bin/mkdir -m $mode -p $(dirname "$path")
    for file in $(cd $(service_dir) && find $path)
    do
      install_file $file $(dirname "/$file")  $ownership $mode
    done
  done
}

# Configure daemons built from source.
# -------------------------------------------------------------------------- #

function on_boot() {
    local service=$1
    until /bin/systemctl is-enabled $service.service 1>/dev/null 2>&1
    do
        /bin/systemctl enable $service.service
        echo "Enabled service $service to start on boot. You should start it now."
    done
    if /bin/systemctl show $service.service | grep 'MainPID=0'
    then
      /bin/systemctl start $service.service
    fi
}

function non_boot()
{
    local service=$1
    if /bin/systemctl is-enabled --quiet $service.service
    then
        /bin/systemctl disable $service.service
        echo "Disable and stopped service $service."
    fi
}

# User and group generation.                                                            
# -------------------------------------------------------------------------- #
# User and group generation functions that check to see if the group already
# exists, followed by the invocation of the functions.
function make_group()
{
    local group=$1; local gid=$2
    current=$(/bin/grep "^${group}:" /etc/group | /bin/cut -d: -f3)
    if [ -z "$current" ]
    then
        echo "Creating group $group."
        /usr/sbin/groupadd --gid $gid $group
    elif [ "$current" != "$gid" ]
    then
        abend "Group $group exists with gid $current instead of $gid."
    fi
}

function make_user()
{
    local user=$1; local uid=$2;
    make_group $user $uid
    current=$(/bin/grep "^${user}:" /etc/passwd | /bin/cut -d: -f3)
    if [ -z "$current" ]
    then
        echo "Creating user $user."
        /usr/sbin/useradd --uid $uid --gid $uid $user
    elif [ "$current" != "$uid" ]
    then
        abend "User $user exists with uid $current instead of $uid."
    fi
}

# Make all of the workers member of the common group.
function group_assign()
{
    local group=$1; min=$2; local max=$3;
    while read line
    do
        user=($(echo $line | /bin/awk -F: '{ print $1, $3 }'))
        if [ "${user[1]}" -ge $min  -a "${user[1]}" -le $max ]; then
            members=$(/bin/grep "^${group}:" /etc/group | /bin/cut -d: -f4)
            if echo $members | /bin/grep -wv ${user[0]} > /dev/null; then
                echo "Adding ${user[0]} to group $group."
                /usr/sbin/usermod -a -G $group ${user[0]} || abend "Cannot add ${user[0]} to $group."
            fi
        fi
    done < /etc/passwd
}
